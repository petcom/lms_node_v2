### ISS-011: Encrypt Identification Numbers at Rest (Security Critical)

**Priority:** critical  
**Type:** feature (security)  
**Status:** pending  
**Assigned:** API Agent  
**Dependencies:** None  

**Description:**
The `IIdentification.idNumber` field in `ILearnerPersonExtended` stores sensitive data (passport numbers, driver's license numbers, alien registration numbers) as **plain text** in MongoDB. This is a critical security and compliance risk.

**Current State:**
```typescript
// src/models/auth/PersonExtended.types.ts:807-815
export const IdentificationSchema = new Schema<IIdentification>({
  idNumber: {
    type: String,
    required: true,
    trim: true
    // NOTE: Should be encrypted before storage ‚Üê Comment only, NOT IMPLEMENTED
  },
});
```

**Risk Assessment:**

| Risk | Severity | Impact |
|------|----------|--------|
| Database breach exposes PII | üî¥ Critical | Passport, driver's license numbers leaked |
| Compliance violation (FERPA, GDPR, state laws) | üî¥ Critical | Legal liability, fines |
| Backup tapes contain plain text PII | üü° Medium | Data exposure from backups |

**Acceptance Criteria:**

**Encryption Implementation:**
- [ ] Create `src/utils/encryption.ts` utility with AES-256-GCM encryption
- [ ] Add pre-save hook to `IdentificationSchema` to encrypt `idNumber`
- [ ] Add getter/virtual to decrypt when reading
- [ ] Support key rotation (version prefix in encrypted data)
- [ ] Encrypt `alienRegistrationNumber` in Demographics if storing full value
- [ ] Add encryption for any other PII fields identified

**Key Management:**
- [ ] Document key storage requirements
- [ ] Add `ENCRYPTION_KEY` environment variable
- [ ] Key must be 256-bit (32 bytes) for AES-256
- [ ] Never commit keys to version control
- [ ] Support key rotation without data loss

**Migration:**
- [ ] Create migration script to encrypt existing plain text data
- [ ] Migration must be idempotent (safe to run multiple times)
- [ ] Backup before migration

**Testing:**
- [ ] Unit tests for encrypt/decrypt functions
- [ ] Integration tests for round-trip (save ‚Üí read)
- [ ] Test key rotation scenario
- [ ] Verify encrypted data format in database

---

### Implementation Details

**1. Encryption Utility:**

```typescript
// src/utils/encryption.ts
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;
const KEY_VERSION = '01'; // For key rotation

export function encrypt(plaintext: string): string {
  const key = getEncryptionKey();
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  
  let encrypted = cipher.update(plaintext, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  // Format: version:iv:authTag:ciphertext
  return `${KEY_VERSION}:${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
}

export function decrypt(encryptedData: string): string {
  const [version, ivHex, authTagHex, ciphertext] = encryptedData.split(':');
  
  const key = getEncryptionKey(version);
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  
  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

export function isEncrypted(value: string): boolean {
  return /^\d{2}:[a-f0-9]{32}:[a-f0-9]{32}:[a-f0-9]+$/.test(value);
}

function getEncryptionKey(version: string = KEY_VERSION): Buffer {
  const keyEnvVar = version === '01' 
    ? 'ENCRYPTION_KEY' 
    : `ENCRYPTION_KEY_V${version}`;
    
  const keyHex = process.env[keyEnvVar];
  if (!keyHex) {
    throw new Error(`Missing encryption key: ${keyEnvVar}`);
  }
  
  return Buffer.from(keyHex, 'hex');
}
```

**2. Schema Integration:**

```typescript
// Add to IdentificationSchema
IdentificationSchema.pre('save', function(next) {
  if (this.isModified('idNumber') && !isEncrypted(this.idNumber)) {
    this.idNumber = encrypt(this.idNumber);
  }
  next();
});

IdentificationSchema.methods.getDecryptedIdNumber = function(): string {
  if (isEncrypted(this.idNumber)) {
    return decrypt(this.idNumber);
  }
  return this.idNumber;
};
```

---

### Key Storage Recommendations

**‚ö†Ô∏è NEVER store encryption keys in:**
- Source code
- Git repositories
- Docker images
- Unencrypted config files
- Environment files committed to VCS

**‚úÖ Recommended Key Storage (by environment):**

| Environment | Recommended Storage | Notes |
|-------------|---------------------|-------|
| **Development** | `.env.local` (gitignored) | Developer-specific, not shared |
| **CI/CD** | GitHub Secrets / GitLab CI Variables | Encrypted at rest, access-controlled |
| **Test/Staging** | AWS Secrets Manager / HashiCorp Vault | Rotatable, audited |
| **Production** | AWS Secrets Manager / HashiCorp Vault / Azure Key Vault | HSM-backed if possible |

**Production Key Management Best Practices:**

1. **AWS Secrets Manager (Recommended for AWS deployments):**
   ```bash
   # Store key
   aws secretsmanager create-secret --name lms/encryption-key --secret-string "$(openssl rand -hex 32)"
   
   # Retrieve in app
   const { SecretsManager } = require('@aws-sdk/client-secrets-manager');
   const client = new SecretsManager({ region: 'us-east-1' });
   const secret = await client.getSecretValue({ SecretId: 'lms/encryption-key' });
   ```

2. **HashiCorp Vault (Recommended for multi-cloud):**
   ```bash
   # Store key
   vault kv put secret/lms/encryption-key value=$(openssl rand -hex 32)
   
   # Retrieve via API or agent
   ```

3. **Environment with Secrets Injection (Kubernetes):**
   ```yaml
   # Use external-secrets-operator or sealed-secrets
   env:
     - name: ENCRYPTION_KEY
       valueFrom:
         secretKeyRef:
           name: lms-encryption-secrets
           key: encryption-key
   ```

**Key Generation:**
```bash
# Generate a cryptographically secure 256-bit key
openssl rand -hex 32
# Example output: a1b2c3d4e5f6...64 hex characters
```

**Key Rotation Process:**
1. Generate new key with new version (e.g., `02`)
2. Add new key to secrets store as `ENCRYPTION_KEY_V02`
3. Keep old key available for decryption
4. Run migration to re-encrypt all data with new key
5. After migration verified, deprecate old key

---

### Related Files (API)

- `src/utils/encryption.ts` - New encryption utility
- `src/models/auth/PersonExtended.types.ts` - Add encryption hooks
- `src/models/auth/Demographics.types.ts` - Encrypt alienRegistrationNumber if needed
- `scripts/migrate-encrypt-pii.ts` - Migration script for existing data
- `.env.example` - Document ENCRYPTION_KEY requirement

**Notes:**
- This is a **security-critical** issue affecting PII protection
- Must be completed before production deployment with real user data
- Consider also encrypting: `visaExpirationDate` context, any other sensitive fields
- MongoDB field-level encryption is an alternative but requires Enterprise

---

